###### UX 
![uxwireframe](../project_images/uxwireframe.png?raw=true "uxwireframe")
Two buttons and an image. Get an image and share it. UX design often strives to be simple and at the same time to give me a sense of control. Don't worry we've got this. We won't bore you with the details but we won't do anything without your permission. You are in control. In this work the UX is simple too. Take a selfie and share it.  It is at the  point that the image is shared that the intervention becomes visible. In a previous incarnation of this work the image was posted and the modifications were only visible when looking at the feed on the internet. In this incarnation the modified image is passed to the Google+ sharing layer where I can choose to share and the scope of the share, but what else does the code do. You'll have to remember the permissions of the app and the preferences you set to get a glimpse. In this case you can read the code and see that I haven't decided what else the software could do.

###### encapsulation
Software hides the boring details. It is built that way. Click a button and share, don't tell me how you do it. Call an API and transform the bitmap, don't tell me how you do it. Unless it breaks. 

###### choices
Platform: Android app because it is intimate. The device is my personal item that knows my history. It is in the palm of my hand. It has power. It has processor cycles, memory and a link to the Internet. 

Themes: Portraits, self-portraits, autoportrait, selfie because it's old and new and personal. Because something/someone else changing/interpreting an image of me could be flattering and/or unnerving. Because it changes how other people see me. Because it reveals and hides something at the same time. Is there a likeness in the portrait? Who can see the likeness, the subject, the algorithm, the people in my circles, the machines on the way? 

Colour choices: A portrait painter looks at the subject and chooses colours possibly based on what she sees. My code looks at the image and chooses colours based on the pixels captured by the CCD and an algorithm. Possibly or not sometimes the pixels are glitched around in the same way memory and data structures are handled. The colour shifts are caused by bits in memory moving around making the process visible.
